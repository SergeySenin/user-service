# Руководство по оформлению юнит-тестов

Данный документ описывает единый стиль написания модульных тестов на базе JUnit 5 и Mockito.

## 1. Общая структура тестов

- Используйте шаблон Arrange-Act-Assert (AAA) для каждого тестового метода.
- Сценарии одной ветки логики группируйте во вложенные классы с `@Nested`,
  а `@DisplayName` формулируйте так, чтобы он отражал контекст проверки.
- На уровне тестового класса, вложенных классов и методов обязательно задавайте аннотацию `@DisplayName`.

## 2. Именование

- Тестовые классы именуйте по шаблону `<ClassName>Test`.
- Тестовые методы именуйте по шаблону `should[ОжидаемыйРезультат]When[Состояние]`.

## 3. Параметризованные тесты

- Для `@ParameterizedTest` сохраняйте паттерн именования `should...When...`
  и задавайте осмысленный `@DisplayName`, описывающий сценарий целиком.
- В качестве источников данных используйте `@MethodSource`, `@CsvSource`
  или фикстуры из `test-utils`, держите входные значения и ожидания неизменяемыми.
- Внутри параметризованного теста соблюдайте AAA: подготовку данных выполняйте в 
  Arrange, вызов SUT — в Act, проверки — в Assert с информативными сообщениями и 
  `assertAll`, если проверок несколько.

## 4. Аннотации Mockito

- Если в тестовом классе используются моки, добавляйте на класс
  `@ExtendWith(MockitoExtension.class)` и `@MockitoSettings(strictness = STRICT_STUBS)`.
- При необходимости подключайте дополнительные расширения через `@ExtendWith` совместно с Mockito;
  использование `MockedStatic` не отменяет требований к аннотациям класса.
- Если моков нет, не добавляйте Mockito-аннотации на класс.

## 5. Создание объекта под тестом (SUT)

- В каждом тестовом методе создавайте SUT локальной переменной вида
  `var sut = createSut();`, где `createSut()` —
  приватный фабричный метод текущего тестового класса.
- Не используйте `@BeforeEach` и `@InjectMocks`.

## 6. Тестовые данные

- Все входные данные и ожидания оформляйте константами.
- Для подготовки данных используйте тестовые билдеры и фикстуры из `test-utils`.
- Общие хелперы размещайте в `test-utils`.

## 7. Проверка взаимодействий

- После шага Act выполняйте `verify(...)` для ожидаемых вызовов.
- Для отсутствия вызовов используйте `verifyNoInteractions(...)`.
- Закрывающие проверки (`verifyNoMoreInteractions(...)`, `only()`) 
  применяйте выборочно — только для критичных моков, когда
  важно зафиксировать отсутствие побочных вызовов. Помните, что
  избыточный контроль взаимодействий делает тесты хрупкими при эволюции реализации.
- Для множественных вызовов используйте только `times(n)`.actions` для этого мока.

## 8. Проверка исключений

- Вызывайте код через `assertThrows`, сохраняйте возвращённое исключение и проверяйте тип.
- Дополнительно проверяйте значимые структурные детали (`errorCode`, `reason`, `cause`, поля доменных DTO`).
- Текст сообщения сравнивайте только если он явно входит в контракт;
  в остальных случаях избегайте жёстких сравнений строк.
- Объединяйте связанные проверки деталей в единый `assertAll` с понятным заголовком и информативными сообщениями.
- После проверки исключения продолжайте контролировать взаимодействия с моками согласно разделу 7.

## 9. Работа со временем и случайностью

- Проверяйте временные значения диапазоном `[lowerBound, upperBound]`.
- Стабилизируйте статические источники случайности через `MockedStatic` в блоке try-with-resources.

## 10. Валидаторы

- Для каждой независимой ветки валидатора пишите отдельный тест.

## 11. DTO и иммутабельность

- Проверяйте копирование данных и выброс `UnsupportedOperationException` при попытке модификации неизменяемых коллекций.

## 12. Детерминизм

- Не используйте `sleep`, сетевые и файловые побочные эффекты.
- Тесты должны выполняться независимо от порядка.

## 13. Стиль и форматирование

- Не используйте `*` в импортируемых пакетах.
- Максимальная длина строки — 120 символов, придерживайтесь форматирования проекта.
- Используйте полные и понятные названия, допускаются только общепринятые аббревиатуры.
- Комментарии и `@SuppressWarnings` должны быть точечными и по делу.

## 14. AssertAll и сообщения

- Группируйте связанные проверки в `assertAll` с заголовком, описывающим контекст.
- Внутренние сообщения обязательны и описывают «что проверяем» и «ожидаемое состояние».
- Порядок аргументов: `expected`, `actual`; не допускается `assertEquals(true/false, ...)`.
- Для тяжёлых сообщений используйте ленивые лямбды.

## 15. Коллекции, массивы и строки

- Используйте `assertIterableEquals` или `assertArrayEquals`; размер коллекции проверяйте отдельно.
- Строки сравнивайте точно; нормализацию применяйте только при наличии такого контракта.

## 16. Дополнительные рекомендации

- В первую очередь проверяйте наблюдаемое поведение:
  возвращаемые значения, изменения состояния, доменные события.
  Проверки взаимодействий и текстов сообщений используйте как
  вспомогательные инструменты, когда они повышают ценность теста.
- Все тесты должны оставаться быстрыми и детерминированными.
- Перед отправкой изменений прогоняйте релевантные тесты и статический анализ при необходимости.
